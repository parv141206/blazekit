"use client";
import Code from "@/components/Code";
import DocsContent, {
  DocsMainTitle,
  DocsTitle,
  PreviousAndNext,
} from "@/components/Docs/DocsContent";
import React from "react";

export default function PostgresDocs() {
  return (
    <DocsContent>
      <DocsMainTitle>PostgreSQL Support</DocsMainTitle>

      <p>
        BlazeKit can generate a complete PostgreSQL controller for your models.
        The generated code uses the <strong>pg</strong> package and assumes a
        standard
        <strong> Next.js</strong> environment with your database URL stored in
        environment variables.
      </p>

      <DocsTitle>What BlazeKit Generates</DocsTitle>
      <p>For each model, BlazeKit creates a PostgreSQL controller with:</p>
      <ul className="list-disc pl-5">
        <li>
          <strong>PostgreSQL Setup</strong> — A <code>Pool</code> instance from
          the <code>pg</code> package is automatically configured.
        </li>
        <li>
          <strong>CRUD Functions</strong> — Create, Read, Update, and Delete
          operations mapped to your SQL tables.
        </li>
      </ul>

      <DocsTitle>Example Output</DocsTitle>
      <p>
        Suppose you have a model <code>User</code>:
      </p>

      <Code
        code={`model User {
  name: string
  email: string
  age: number
}`}
        fileName="schema.blaze"
      />

      <p>BlazeKit will generate the following PostgreSQL controller:</p>

      <Code
        smaller={true}
        code={`// PostgreSQL Setup (auto-generated)
import { Pool } from "pg";
import { User } from "../types";

const pool = new Pool({
  connectionString: process.env.POSTGRES_URL,
});

// CRUD Operations for User

export async function createUser(data: User) {
  const keys = Object.keys(data);
  const values = Object.values(data);
  const placeholders = keys.map((_, i) => \`$\${i + 1}\`).join(", ");
  const query = \`INSERT INTO users (\${keys.join(", ")}) VALUES (\${placeholders}) RETURNING *\`;

  const result = await pool.query(query, values);
  return result.rows[0];
}

export async function getAllUsers() {
  const result = await pool.query("SELECT * FROM users");
  return result.rows;
}

export async function getUserById(id: string) {
  const result = await pool.query("SELECT * FROM users WHERE id = $1", [id]);
  return result.rows[0];
}

export async function updateUser(id: string, data: Partial<User>) {
  const keys = Object.keys(data);
  const values = Object.values(data);
  const setClause = keys.map((key, i) => \`\${key} = $\${i + 1}\`).join(", ");
  const query = \`UPDATE users SET \${setClause} WHERE id = $\${keys.length + 1} RETURNING *\`;

  const result = await pool.query(query, [...values, id]);
  return result.rows[0];
}

export async function deleteUser(id: string) {
  const result = await pool.query("DELETE FROM users WHERE id = $1 RETURNING *", [id]);
  return result.rows[0];
}`}
        fileName="controllers/user.ts"
      />

      <DocsTitle>Notes</DocsTitle>
      <ul className="list-disc pl-5">
        <li>
          BlazeKit expects your PostgreSQL connection string to be available as{" "}
          <code>POSTGRES_URL</code> in your environment variables (or a custom
          name if configured).
        </li>
        <li>
          Table names are generated by taking the model name in lowercase and
          adding an "s" (e.g., <code>User</code> → <code>users</code>).
        </li>
        <li>All queries are parameterized to prevent SQL injection.</li>
        <li>
          Returned results include all columns from the table, including the{" "}
          <code>id</code>.
        </li>
      </ul>

      <PreviousAndNext
        previous={{
          title: "Firebase",
          path: "/docs/concepts/firebase",
        }}
        next={{
          title: "Prisma",
          path: "/docs/concepts/prisma",
        }}
      />
    </DocsContent>
  );
}
